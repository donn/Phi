module processor_control(
  opcode: Input[5..0],
  RegDst: Output,
  ALUSrc: Output,
  MemtoReg: Output,
  RegWrite: Output,
  MemRead: Output,
  MemWrite: Output,
  Branch: Output,
  BranchEqual: Output,
  BranchNotEqual: Output,
  ALUOp: Output[1..0],
  Jump: Output
){

/*
          format     opcode    function/opcode
add --> r format --> 000000 --> 100000
sub --> r format --> 000000 --> 100010
lsl --> r format --> 000000 --> 000000
lsr --> r format --> 000000 --> 000010
and --> r format --> 000000 --> 100100
or  --> r format --> 000000 --> 100101
slt --> r format --> 000000 --> 101010
lw  --> i format --> 100011
sw  --> i format --> 101011
beq --> i format --> 000100
bne --> i format --> 000101
j   --> j format --> 000010
*/

/*
instr     RegDst ALUSrc MemtoReg RegWrite MemRead MemWrite Branch ALUOp Jump
data-pr    1       0      0        1        0       0        0     00    0
lw         0       1      1        1        1       0        0     10    0
sw         0       1      0        0        0       1        0     10    0
beq,bne    0       0      0        0        0       0        1     01    0
j          0       0      0        0        0       0        0     00    1
*/

  comb {
    switch(opcode){
      case 100000:
        //add
        // RegDst ALUSrc MemtoReg RegWrite MemRead MemWrite Branch ALUOp Jump
        //   1       0      0        1        0       0        0     00    0
        RegDst = 1b1;
        ALUSrc = 1b0;
        MemtoReg = 1b0;
        RegWrite = 1b1;
        MemRead = 1b0;
        MemWrite = 1b0;
        Branch = 1b0;
        BranchEqual = 1b0;
        BranchNotEqual = 1b0;
        ALUOp = 2b00;
        Jump = 1b0;

      case 100010:
        //sub
        // RegDst ALUSrc MemtoReg RegWrite MemRead MemWrite Branch ALUOp Jump
        //   1       0      0        1        0       0        0     00    0
        RegDst = 1b1;
        ALUSrc = 1b0;
        MemtoReg = 1b0;
        RegWrite = 1b1;
        MemRead = 1b0;
        MemWrite = 1b0;
        Branch = 1b0;
        BranchEqual = 1b0;
        BranchNotEqual = 1b0;
        ALUOp = 2b00;
        Jump = 1b0;

      case 000000:
        //lsl
        // RegDst ALUSrc MemtoReg RegWrite MemRead MemWrite Branch ALUOp Jump
        //   1       0      0        1        0       0        0     00    0
        RegDst = 1b1;
        ALUSrc = 1b0;
        MemtoReg = 1b0;
        RegWrite = 1b1;
        MemRead = 1b0;
        MemWrite = 1b0;
        Branch = 1b0;
        BranchEqual = 1b0;
        BranchNotEqual = 1b0;
        ALUOp = 2b00;
        Jump = 1b0;

      case 000010:
        //lsr
        // RegDst ALUSrc MemtoReg RegWrite MemRead MemWrite Branch ALUOp Jump
        //   1       0      0        1        0       0        0     00    0
        RegDst = 1b1;
        ALUSrc = 1b0;
        MemtoReg = 1b0;
        RegWrite = 1b1;
        MemRead = 1b0;
        MemWrite = 1b0;
        Branch = 1b0;
        BranchEqual = 1b0;
        BranchNotEqual = 1b0;
        ALUOp = 2b00;
        Jump = 1b0;

      case 100100:
        //and
        // RegDst ALUSrc MemtoReg RegWrite MemRead MemWrite Branch ALUOp Jump
        //   1       0      0        1        0       0        0     00    0
        RegDst = 1b1;
        ALUSrc = 1b0;
        MemtoReg = 1b0;
        RegWrite = 1b1;
        MemRead = 1b0;
        MemWrite = 1b0;
        Branch = 1b0;
        BranchEqual = 1b0;
        BranchNotEqual = 1b0;
        ALUOp = 2b00;
        Jump = 1b0;

      case 100101:
      //or
      // RegDst ALUSrc MemtoReg RegWrite MemRead MemWrite Branch ALUOp Jump
      //   1       0      0        1        0       0        0     00    0
      RegDst = 1b1;
      ALUSrc = 1b0;
      MemtoReg = 1b0;
      RegWrite = 1b1;
      MemRead = 1b0;
      MemWrite = 1b0;
      Branch = 1b0;
      BranchEqual = 1b0;
      BranchNotEqual = 1b0;
      ALUOp = 2b00;
      Jump = 1b0;

      case 101010:
        //slt
        // RegDst ALUSrc MemtoReg RegWrite MemRead MemWrite Branch ALUOp Jump
        //   1       0      0        1        0       0        0     00    0
        RegDst = 1b1;
        ALUSrc = 1b0;
        MemtoReg = 1b0;
        RegWrite = 1b1;
        MemRead = 1b0;
        MemWrite = 1b0;
        Branch = 1b0;
        BranchEqual = 1b0;
        BranchNotEqual = 1b0;
        ALUOp = 2b00;
        Jump = 1b0;

      case 100011:
        //lw
        // RegDst ALUSrc MemtoReg RegWrite MemRead MemWrite Branch ALUOp Jump
        //   0       1      1        1        1       0        0     10    0
        RegDst = 1b0;
        ALUSrc = 1b1;
        MemtoReg = 1b1;
        RegWrite = 1b1;
        MemRead = 1b1;
        MemWrite = 1b0;
        Branch = 1b0;
        BranchEqual = 1b0;
        BranchNotEqual = 1b0;
        ALUOp = 2b10;
        Jump = 1b0;

      case 101011:
        //sw
        // RegDst ALUSrc MemtoReg RegWrite MemRead MemWrite Branch ALUOp Jump
        //  0       1      0        0        0       1        0     10    0
        RegDst = 1b0;
        ALUSrc = 1b1;
        MemtoReg = 1b0;
        RegWrite = 1b0;
        MemRead = 1b0;
        MemWrite = 1b1;
        Branch = 1b0;
        BranchEqual = 1b0;
        BranchNotEqual = 1b0;
        ALUOp = 2b10;
        Jump = 1b0;

      case 000100:
        //beq
        // RegDst ALUSrc MemtoReg RegWrite MemRead MemWrite Branch ALUOp Jump
        //  0       0      0        0        0       0        1     01    0
        RegDst = 1b0;
        ALUSrc = 1b0;
        MemtoReg = 1b0;
        RegWrite = 1b0;
        MemRead = 1b0;
        MemWrite = 1b0;
        Branch = 1b1;
        BranchEqual = 1b1;
        BranchNotEqual = 1b0;
        ALUOp = 2b01;
        Jump = 1b0;

      case 000101:
        //bne
        // RegDst ALUSrc MemtoReg RegWrite MemRead MemWrite Branch ALUOp Jump
        //   0       0      0        0        0       0        1     01    0
        RegDst = 1b0;
        ALUSrc = 1b0;
        MemtoReg = 1b0;
        RegWrite = 1b0;
        MemRead = 1b0;
        MemWrite = 1b0;
        Branch = 1b1;
        BranchEqual = 1b0;
        BranchNotEqual = 1b1;
        ALUOp = 2b01;
        Jump = 1b0;

      case 000010:
        //j
        // RegDst ALUSrc MemtoReg RegWrite MemRead MemWrite Branch ALUOp Jump
        //   0       0      0        0        0       0        0     00    1
        RegDst = 1b0;
        ALUSrc = 1b0;
        MemtoReg = 1b0;
        RegWrite = 1b0;
        MemRead = 1b0;
        MemWrite = 1b0;
        Branch = 1b0;
        BranchEqual = 1b0;
        BranchNotEqual = 1b0;
        ALUOp = 2b00;
        Jump = 1b1;

    }
  }
}
