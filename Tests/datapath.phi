module datapath(
  clk: @clock Input,
  rst: @reset Input,
  RegDst: Input,
  ALUSrc: Input,
  MemtoReg: Input,
  RegWrite: Input,
  MemRead: Input,
  MemWrite: Input,
  Branch: Input,
  BranchEqual: Input,
  BranchNotEqual: Input,
  ALUOp: Input[1..0],
  Jump: Input,
  opcode: Output[5..0]
){

  /* program counter */

  Register[31..0] pc = 32b0;
  Var[31..0] next_pc = 32b0;
  Wire[31..0] pc_4;
  //at the positive edge of the clock, pc = next_pc
  comb {
    pc.data = next_pc;
  }
  pc_4 = pc.data + 3d4;



  /* instruction memory */
  // instruction_memory( pc: Input[31..0], instruction: Output[31..0])

  //output
  Wire[31..0] instr;
  //calling the instruction memory module
  instruction_memory imem ( pc: pc, instruction: instr);



  /* register file */
  /*  register_file(clk: @clock Input, rst: @reset Input, RegWrite: @enable Input,
      write_address: Input[4..0], write_data: Input[31..0],
      read_address_1: Input[4..0], read_address_2: Input[4..0],
      read_data_1: Output[31..0], read_data_2: Output[31..0]) */

  //inputs
  Wire[4..0] write_address = mux(RegDst==0)  (1b0: instr[20..16] , 1b1: instr[15..11]);
  Wire[31..0] write_data;
  Wire[4..0] read_address_1 = instr[25..21];
  Wire[4..0] read_address_2 = instr[20..16];
  //outputs
  Wire[31..0] read_data_1;
  Wire[31..0] read_data_2;
  //calling the register file module
  register_file rf (clk: clk , rst: rst , RegWrite: RegWrite,
      write_address: write_address, write_data: write_data,
      read_address_1: read_address_1, read_address_2: read_address_2,
      read_data_1: read_data_1, read_data_2: read_data_2);




  /* alu control unit */
  //alu_controlUnit(ALUOp: Input[1..0], opcode: Input[5..0], alu_control: Output[1..0])

  //output
  Wire[2..0] alu_control;
  // calling alu control unit module
  alu_controlUnit alucontrolunit (ALUOp: ALUOp, opcode: instr[5..0], alu_control: alu_control);




  /* alu unit*/
  /* alu(data_1: Input[31..0],data_2: Input[31..0],alu_control: Input[2..0],
         result: Output[31..0],zero_flag: Output) */

  //some needed processing
  Wire[15..0] immediate_before_extend = instr[15..0];
  Wire[31..0] immediate_after_extend = {16b0,immediate_before_extend};
  //inputs
  Wire[31..0] read_data_2_modified = mux(ALUSrc==1b0) (1b0: read_data_2, 1b1: immediate_after_extend)
  //outputs
  Wire[31..0] alu_result;
  Wire zero_flag;
  //calling alu unit module
  alu myalu(data_1: read_data_1 ,data_2: read_data_2_modified , alu_control: alu_control,
      result: alu_result, zero_flag: zero_flag);




  /* update pc depending on the zero_flag that comes out from alu unit */
  //pc_beq
  Wire[31..0] pc_beq;
  pc_beq = pc_4 + {immediate_after_extend[31..2],2b00}

  //pc_bne
  Wire[31..0] pc_bne;
  pc_bne = pc_4 + {immediate_after_extend[31..2],2b00}

  //pc_j
  Wire[31..0] pc_j;
  pc_j = {pc_4[31..28],instr[25..0],2b00}

  //pc_control
  Wire beq_control = zero_flag & BranchEqual;
  Wire bne_control = ~zero_flag & BranchNotEqual;

  //next_pc (getting next_pc using multiple of mux(s))
  Wire pc_step1 = mux(beq_control==1b1) (1b1: pc_beq , 1b0: pc_4)
  Wire pc_step2 = mux(bne_control==1b1) (1b1: pc_bne, 1b0: pc_step1)
  Wire pc_step3 = mux(Jump==1b1) (1b1: pc_j , 1b0: pc_step2)
  next_pc = pc_step3;




  /* data memory */
  /* data_memory(clk: @clock Input, address: Input[31..0],
    MemWrite: @enable Input, MemRead: Input,
    write_data: Input[31..0], read_data: Output[31..0])*/

    //outputs
    Wire[31..0] read_data;
    //calling data memory module
    data_memory dmem(clk: clk , address: alu_result, MemWrite: MemWrite,
                MemRead: MemRead, write_data: read_data_2, read_data: read_data);




  /* write back to register file*/
  write_data = mux(MemtoReg==1b0) (1b0: alu_result, 1b1: read_data)




  /* output opcode to control unit */
  opcode = instr[31..26];
}
