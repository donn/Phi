/*
    dwarfRV32 SoC AHB-Lite Memory
    Created by Mohamed Shalan
    Translated to Phi by Mohamed Gaber
    --
    Â©2016-2018 Cloud V
*/
module Memory<memoryWidth>(): Slave {
    namespace AddressPhase {
        Register HSEL = 1b0;
        Register HWRITE = 1b0;
        Register[1..0] HTRANS = 2b0;
        Register[31..0] HADDR = 32b0;
        Register[2..0] HSIZE =  3b0;
    }
    
    Var[31..0] memorySize = $pow(2, memoryWidth - 2);
    Var[31..0] memoryMax = memoryWidth - 1;

    Register[31..0] storage[memorySize];
    for i in 0..memoryMax {
        storage[i] = 32b0; // Setting reset values
    }

    async {
        if HREADY | WAIT {
            AddressPhase.HSEL.data = HSEL;
            AddressPhase.HWRITE.data = HWRITE;
            AddressPhase.HTRANS.data = HTRANS;
            AddressPhase.HADDR.data = HADDR;
            AddressPhase.HSIZE.data = HSIZE;
        } else {
            AddressPhase.HSEL.data = AddressPhase.HSEL;
            AddressPhase.HWRITE.data = AddressPhase.HWRITE;
            AddressPhase.HTRANS.data = AddressPhase.HTRANS;
            AddressPhase.HADDR.data = AddressPhase.HADDR;
            AddressPhase.HSIZE.data = AddressPhase.HSIZE;
        }
    }

    //Byte lane decoding
    Wire byteTransaction = ~AddressPhase.HSIZE[1] & ~AddressPhase.HSIZE[0];
    Wire halfTransaction = ~AddressPhase.HSIZE[1] & AddressPhase.HSIZE[0];
    Wire wordTransaction = ~AddressPhase.HSIZE[1];

    Wire byte_at_00 = byteTransaction & ~AddressPhase.HADDR[1] & ~AddressPhase.HADDR[0];
    Wire byte_at_01 = byteTransaction & ~AddressPhase.HADDR[1] &  AddressPhase.HADDR[0];
    Wire byte_at_10 = byteTransaction &  AddressPhase.HADDR[1] & ~AddressPhase.HADDR[0];
    Wire byte_at_11 = byteTransaction &  AddressPhase.HADDR[1] &  AddressPhase.HADDR[0];

    Wire half_at_00 = halfTransaction & ~AddressPhase.HADDR[1];
    Wire half_at_10 = halfTransaction &  AddressPhase.HADDR[1];

    Wire word_at_00 = wordTransaction;

    Wire byte0 = word_at_00 | half_at_00 | byte_at_00;
    Wire byte1 = word_at_00 | half_at_00 | byte_at_01;
    Wire byte2 = word_at_00 | half_at_10 | byte_at_10;
    Wire byte3 = word_at_00 | half_at_10 | byte_at_11;

    Wire effectiveAddress = AddressPhase.HADDR[memoryMax..2];

    Register[31..0] readOut;

    async {
        memory[effectiveAddress][7..0].data = memory[effectiveAddress][7..0];
        memory[effectiveAddress][15..8].data = memory[effectiveAddress][15..8];
        memory[effectiveAddress][23..16].data = memory[effectiveAddress][23..16];
        memory[effectiveAddress][31..24].data = memory[effectiveAddress][31..24];
        if AddressPhase.HSEL & AddressPhase.HWRITE & AddressPhase.HTRANS[1] {
            if byte0 {
                memory[effectiveAddress][7..0].data = HWDATA[7..0];
            }
            if byte1 {
                memory[effectiveAddress][15..8].data = HWDATA[15..8];
            }
            if byte2 {
                memory[effectiveAddress][23..16].data = HWDATA[23..16];
            }
            if byte3 {
                memory[effectiveAddress][31..24].data = HWDATA[31..24];
            }
        }
    }
    readOut.data = memory[effectiveAddress];

    Wire CEWR = AddressPhase.HWRITE & AddressPhase.HSEL; // Expect a write
    Wire CERD = HSEL & ~HWRITE;

    Wire MUTEX = CERD ^ CEWR;
    Wire WAIT = CERD & CEWR;

    Wire CE = MUTEX ? 1b1 : WAIT ? CEWR : 1b0;

    HREADYOUT = ~WAIT;
    HRDATA = readOut;
}