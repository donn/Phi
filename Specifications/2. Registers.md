# 2. Registers
Registers represent a unit of storage in Phi. They are roughly analogous to D-flipflops in actual hardware.

As hardware is perpetual, registers are coupled with a **clock** signal to make hardware a function in its **state** as well as its inputs and outputs.

Registers are more structural in approach, generally. These properties are all treated as wires by the language.

Like wires, register values can be read. However, assignments work in a very special manner, as you will see in the **Resetting** section. You cannot assign to a wire inside an `async` block.

Register clocking and reset signals are done in a structural manner as procedural blocks for registers are an undesirable abstraction for a language aimed to remove ambiguity in hardware design.

## 2.1 Clocking
```phi
    Register[31..0] register;
    register.clock = clock;
    register.data  = register &+ 32b1;
```

This declares a one bit register clocked with `clock`. When clock is at the positive edge, the register's value becomes the expression assigned to the wire `register.data`: in this case, it would be the value of the register added to 1.

## 2.2 Resetting
### 2.2.1 Synchronous
Synchronous resets are straightforward:

```phi
    register.data = reset ? register &+ 32b1 : 32b0;
```

### 2.2.2 Asynchronous
Asynchronous resets are slightly more verbose.

```phi
    register.reset = reset; // High
    register.reset = ~reset; // Low
```

Registers take their initial assigned value when reset asynchronously, i.e. you would have to assign the register a value at some point in the code.

Here are some valid options:

```phi
    Register register = 1b0;
    register.reset = reset;
```

```phi
    Register register;
    register.reset = reset;

    register = 1b0;
```

## 2.3 Shorthand Annotations
In port declarations, you can quickly specify which ports are supposed to be clocks and resets as typically, clocking every single register can be a chore.

```phi
module Counter(
    clock: @clock Input,
    reset: @resetLow Input,
    output: Output[31..0]
) 
```

This will set it so all registers declared within counter automatically have their clock signal set to `clock` and their reset signal set to `~reset`.

There are four such annotations: `clock`, `clockLow`, `reset` and `resetLow`:

0. `clock` uses the positive edge of the clock.
1. `clockLow` uses the negative edge of the clock.
2. `reset` uses an active-high reset.
3. `resetLow` uses an active-low reset.